# Anonymous Survey System - Workflow Verification Tests

This document explains the comprehensive workflow verification tests for the anonymous survey system. These tests verify the cryptographic integrity of the complete survey process from student participation to school verification.

## Overview

The workflow verification tests cover three critical aspects of the anonymous survey system:

1. **Student Answer Verification** - Verifies that student answers can be authenticated using blind signatures
2. **Merkle Tree Answer Verification** - Verifies that specific answers belong to a survey using Merkle tree proofs
3. **Database-Blockchain Consistency** - Verifies that the school's database matches the blockchain state

## Running the Tests

### Prerequisites

Make sure you have Node.js 16+ installed and the dependencies are installed:

```bash
cd protocol-test
npm install
```

### Run All Tests

```bash
npm run test-workflow
```

This will:
1. Build the TypeScript code
2. Run all three verification tests
3. Display detailed results

### Run Individual Tests

You can also import and run individual tests in your own code:

```typescript
import { 
  testStudentAnswerVerification,
  testMerkleTreeAnswerVerification,
  testDatabaseBlockchainConsistency 
} from './workflow-verification';

// Run individual tests
const result1 = await testStudentAnswerVerification();
const result2 = await testMerkleTreeAnswerVerification();
const result3 = await testDatabaseBlockchainConsistency();
```

## Test Details

### Test 1: Student Answer Verification

**Purpose**: Verify that student answers can be authenticated using the school's blind signature private key.

**What it tests**:
- Generate survey keys (simulating school setup)
- Student creates and blinds their answer
- School signs the blinded message
- Student finalizes the signature
- School verifies the answer using stored private key
- Rejection of tampered answers

**Real-world usage**: 
- School can verify that downloaded student proofs are authentic
- Ensures answers truly belong to the survey
- Detects any tampering with student responses

**Example output**:
```
🔍 Test 1: Student Answer Verification
=====================================
✅ Survey keys generated and exported
📝 Student answer: "The event was very informative..."
🔒 Message blinded successfully
✍️ Blind signature generated by school
🔑 Signature finalized by student
✅ Student answer signature is VALID
✅ Answer authentically belongs to this survey
✅ Tampered answer correctly REJECTED
```

### Test 2: Merkle Tree Answer Verification

**Purpose**: Verify that a specific answer belongs to a survey using Merkle tree proofs.

**What it tests**:
- Create survey responses and their commitments
- Build Merkle tree from commitments
- Generate and verify Merkle proofs for individual answers
- Reject fake answers not in the tree
- Reject proofs with wrong Merkle roots

**Real-world usage**:
- Verify that published results include all submitted answers
- Prove that a specific answer was part of the original survey
- Public verification of survey integrity

**Example output**:
```
🌳 Test 2: Merkle Tree Answer Verification
==========================================
📊 Testing with 5 survey responses
🔗 Commitments created for all responses
🌳 Merkle tree built with root: 1a2b3c4d...
✅ Answer VERIFIED as belonging to this survey
✅ Fake answer correctly NOT FOUND in Merkle tree
✅ Wrong root correctly REJECTED
```

### Test 3: Database-Blockchain Consistency

**Purpose**: Verify that the Merkle root calculated from database commitments matches the blockchain root.

**What it tests**:
- Calculate Merkle root from database responses
- Compare with blockchain-stored root
- Detect database tampering
- Verify individual responses against blockchain

**Real-world usage**:
- Ensure school hasn't tampered with results after collection
- Verify consistency between local database and blockchain
- Public auditing of survey results

**Example output**:
```
⛓️  Test 3: Database vs Blockchain Consistency
==============================================
📊 Database contains 5 decrypted responses
🗄️  Database Merkle root: 1a2b3c4d...
⛓️  Blockchain Merkle root: 1a2b3c4d...
✅ Database and blockchain roots MATCH
✅ Survey integrity VERIFIED
✅ Tampered database correctly DETECTED
```

## Integration with Real System

### For Student Verification

When students download their participation proof, they receive:
- Their original answer
- The prepared message (`preparedMsg`)
- The final signature (`finalSignature`)

To verify in production:

```typescript
// Get blind signature private key from database
const survey = await prisma.survey.findUnique({
  where: { id: surveyId },
  include: { privateKey: true }
});

const blindPrivateKey = Buffer.from(
  survey.privateKey.blindSignaturePrivateKey, 
  'base64'
);

// Import and verify using the test functions
const isValid = await verifyStudentProof(
  studentAnswer,
  preparedMessage,
  finalSignature,
  blindPrivateKey
);
```

### For School Verification

#### Merkle Tree Verification

```typescript
// Get all commitments from database
const responses = await prisma.surveyResponse.findMany({
  where: { surveyId },
  select: { commitmentHash: true }
});

const commitments = responses.map(r => 
  Buffer.from(r.commitmentHash, 'hex')
);

// Verify specific answer
const merkleTree = new MerkleTree(commitments);
const proof = merkleTree.getProof(answerCommitment);
const isValid = MerkleTree.verifyProof(
  answerCommitment, 
  proof, 
  merkleTree.getRoot()
);
```

#### Database-Blockchain Consistency

```typescript
// Calculate database root
const databaseCommitments = await getDatabaseCommitments(surveyId);
const databaseRoot = new MerkleTree(databaseCommitments).getRoot();

// Get blockchain root
const blockchainSurvey = await blockchainService.getSurvey(shortId);
const blockchainRoot = Buffer.from(blockchainSurvey.data.merkleRoot);

// Verify consistency
const isConsistent = databaseRoot.equals(blockchainRoot);
```

## Security Considerations

1. **Private Key Security**: The blind signature private key must be securely stored and only accessible to authorized school personnel.

2. **Merkle Tree Implementation**: The Merkle tree implementation must be consistent between client and server to ensure compatibility.

3. **Commitment Generation**: The commitment generation algorithm must be identical across all components.

4. **Blockchain Integration**: The blockchain integration must ensure that the stored Merkle roots are immutable and verifiable.

## Expected Test Results

All tests should pass with the following validations:

✅ **Test 1**: Student answers can be verified with blind signatures  
✅ **Test 2**: Merkle tree proofs work correctly for answer verification  
✅ **Test 3**: Database and blockchain consistency can be verified  

If any test fails, it indicates a potential issue with the cryptographic implementation or data integrity.

## Troubleshooting

### Common Issues

1. **Key Import Errors**: Ensure RSA keys are properly formatted and exported
2. **Merkle Tree Mismatches**: Verify consistent hashing algorithms
3. **Signature Verification Failures**: Check that the blind signature implementation matches

### Debug Output

Enable detailed logging by modifying the test functions to include additional console output for debugging specific issues.

## Files

- `workflow-verification.ts` - Main test implementation
- `package.json` - Includes `test-workflow` script
- `WORKFLOW_TESTING.md` - This documentation file 